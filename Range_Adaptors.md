#Адаптеры

Стандартная библиотека предоставляет несколько алгоритмов, которым Вы можете передать предикат. Например, предикат переданный в `std::count_if()` определяет, какие элементы были посчитаны. Boost.Range обеспечивает подобное с `boost::count_if()`. Однако этот алгоритм предоставлен только для полноты, потому что Boost.Range обеспечивает адаптеры, которые делают алгоритмы с предикатами лишними.

Вы можете думать об *адаптерах* как о фильтрах. Они возвращают новый диапазон (тот, что range) на основе другого диапазона. Данные не обязательно копируются. Так как диапазон - просто пара итераторов, адаптер возвращает новую пару. Пара все еще может использоваться, чтобы перебирать оригинальный диапазон, но и может, например, пропустить определенные элементы. Если `boost::count()` используется с таким адаптером, `boost::count_if()` больше не требуется. Алгоритмы не должны быть многократно определены именно так, их можно вызвать и с и без предикатов.

Различие между алгоритмами и адаптерами в том, что алгоритмы перебирают в диапазоне и обрабатывают данные, в то время как адаптеры возвращают новый диапазон – новые итераторы – который определяет, какие элементы возвращает итерация. Однако, никакой итерации не будет выполнено. Алгоритм нужно сперва вызвать.

<a name="ex.range_04"/>
Пример 30.4. Фильтруем диапозон с `boost::adaptors::filter()`
```c++
#include <boost/range/algorithm.hpp>
#include <boost/range/adaptors.hpp>
#include <array>
#include <iterator>
#include <iostream>

int main()
{
  std::array<int, 6> a{{0, 5, 2, 1, 3, 4}};
  boost::copy(boost::adaptors::filter(a, [](int i){ return i > 2; }),
    std::ostream_iterator<int>{std::cout, ","});
}
```
[Пример 30.4](#ex.range_04) использует адаптер, который может фильтровать диапазоны. Как видете, адаптер это просто функция. `boost::adaptors::filter()` принимает первым параметром диапазон для фильтрации и вторым параметром предикат. Предикат в [Примере 30.4](#ex.range_04) удаляет все числа не больше 2 из диапозона.  

`boost::adaptors::filter()` не меняет диапозон **a**, он возвращает новый диапазон. Так как диапазон это ничто иное, как пара итераторов, то эти итераторы будут ссылаться на **a**. Тем не менее, итераторы нового диапазона пропускают все числа меньше или равные 2.

[Пример 30.4](#ex.range_04) выведет `5,3,4` в стандартный поток вывода.

<a name="ex.range_05"/>
Пример 30.5. Использование `keys()`, `values()` и `indirect()`
```c++
#include <boost/range/algorithm.hpp>
#include <boost/range/adaptors.hpp>
#include <array>
#include <map>
#include <string>
#include <utility>
#include <iterator>
#include <iostream>

int main()
{
  std::array<int, 3> a{{0, 1, 2}};
  std::map<std::string, int*> m;
  m.insert(std::make_pair("a", &a[0]));
  m.insert(std::make_pair("b", &a[1]));
  m.insert(std::make_pair("c", &a[2]));

  boost::copy(boost::adaptors::keys(m),
    std::ostream_iterator<std::string>{std::cout, ","});
  boost::copy(boost::adaptors::indirect(boost::adaptors::values(m)),
    std::ostream_iterator<int>{std::cout, ","});
}
```

[Пример 30.5](#ex.range_05) использует два адаптера, `boost::adaptors::keys()` и `boost::adaptors::values()`, чтобы получить доступ к ключам и значениям в контейнере `std::map`. Также это показывает как адаптеры могут быть вложены. Т.к. **m** хранит указатели на значения, которые нужно напечатать, нежели чем сами значения, диапазон, возвращаемый `boost::adaptors::values()` передается в `boost::adaptors::indirect()`. Этот адаптер всегда может быть использован когда диапазон состоит из указателей, но итерация должна вернуть нам значения, на которые ссылаются указатели. Вот почему [Пример 30.5](#ex.range_05) выведет `a,b,c,0,1,2,`.

<a name="ex.range_06"/>
Пример 30.6. `boost::adaptors::tokenize()` - адаптор для строк
```c++
#include <boost/range/algorithm.hpp>
#include <boost/range/adaptors.hpp>
#include <boost/regex.hpp>
#include <string>
#include <iostream>

int main()
{
  std::string s = "The Boost C++ Libraries";
  boost::regex expr{"[\\w+]+"};
  boost::copy(boost::adaptors::tokenize(s, expr, 0,
    boost::regex_constants::match_default),
    std::ostream_iterator<std::string>{std::cout, ","});
}
```

[Пример 30.6](#ex.range_06) представляет вам работу с адаптером для строк. Можете использовать `boost::adaptors::tokenize()` чтобы получить диапазон из строки с помощью регулярного выражения. Вы передаете строчку и регулярное выражение типа `boost::regex` в `boost::adaptors::tokenize()`. В дополнении нужно будет еще передать число, которое относится к группе в регулярном выражении и флаг. Если никакая группа не используется, можете передать 0. Флаг **boost::regex_constants::match_default** назначает дефолтные настройки для регулярных выражений. Можно передать и другие флаги. Например, можете использовать флаг **boost::regex_constants::match_perl** если хотите, чтобы регулярное выражение применялось по правилам языка программирования Perl. 
